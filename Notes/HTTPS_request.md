HTTP（HyperText Transfer Protocol）和 HTTPS（HTTP Secure）是用于在客户端和服务器之间传输数据的应用层协议。HTTPS 是 HTTP 的安全版本，通过 TLS/SSL 加密传输数据。以下是 HTTP(S) 协议的核心概念和常见的请求方法（Request Methods）的详细说明：

---

### **HTTP(S) 协议概述**
1. **HTTP**：
   - 无状态协议（每个请求独立，服务器不保留上下文）。
   - 默认端口 `80`。
   - 明文传输，不安全。

2. **HTTPS**：
   - HTTP + TLS/SSL 加密。
   - 默认端口 `443`。
   - 提供数据加密、身份验证（证书）和完整性保护。

---

### **HTTP 请求方法（Request Methods）**
HTTP 定义了一组请求方法（也称为 HTTP 动词），用于指定客户端希望服务器执行的操作。

| 方法        | 用途                                           | 是否幂等 | 是否有请求体 |
| ----------- | ---------------------------------------------- | -------- | ------------ |
| **GET**     | 获取资源（查询数据）。                         | 是       | 通常无       |
| **POST**    | 提交数据（创建资源或触发处理）。               | 否       | 有           |
| **PUT**     | 替换整个资源（全量更新）。                     | 是       | 有           |
| **PATCH**   | 部分更新资源（增量更新）。                     | 否       | 有           |
| **DELETE**  | 删除资源。                                     | 是       | 通常无       |
| **OPTIONS** | 获取服务器支持的通信选项（如支持的请求方法）。 | 是       | 无           |

---

### **详细说明**
#### 1. **GET**
- **用途**：请求服务器返回指定资源（只读操作）。
- **示例**：
  
  ```http
  GET /api/users?id=1 HTTP/1.1
  ```
- **特点**：
  - 参数通过 URL 传递（查询字符串 `?key=value`）。
  - 可被缓存、书签保存。
  - 不应修改服务器数据（符合幂等性）。

#### 2. **POST**
- **用途**：向服务器提交数据（常用于创建资源或非幂等操作）。
- **示例**：
  ```http
  POST /api/users HTTP/1.1
  Content-Type: application/json
  
  {"name": "Alice", "age": 25}
  ```
- **特点**：
  - 数据通过请求体（Body）传输（支持 JSON、表单等格式）。
  - 不幂等（多次调用可能产生不同结果，如重复提交订单）。

#### 3. **PUT**
- **用途**：替换目标资源的全部内容（全量更新）。
- **示例**：
  ```http
  PUT /api/users/1 HTTP/1.1
  Content-Type: application/json
  
  {"name": "Alice", "age": 26}
  ```
- **特点**：
  - 幂等（多次调用结果一致）。
  - 需提供完整的资源数据（缺失字段可能被置为默认值）。

#### 4. **PATCH**
- **用途**：部分更新资源（仅发送需要修改的字段）。
- **示例**：
  
  ```http
  PATCH /api/users/1 HTTP/1.1
  Content-Type: application/json
  
  {"age": 27}
  ```
- **特点**：
  
  - 非幂等（依赖实现方式）。
  - 比 PUT 更节省带宽。

#### 5. **DELETE**
- **用途**：请求服务器删除指定资源。
- **示例**：
  ```http
  DELETE /api/users/1 HTTP/1.1
  ```
- **特点**：
  - 幂等（多次删除结果相同）。
  - 成功通常返回 `204 No Content`。

#### 6. **OPTIONS**
- **用途**：获取服务器支持的请求方法（常用于跨域请求预检）。
- **示例**：
  ```http
  OPTIONS /api/users HTTP/1.1
  ```
- **响应示例**：
  ```http
  HTTP/1.1 200 OK
  Allow: GET, POST, PUT, DELETE
  ```

---

### **其他注意事项**
1. **幂等性（Idempotent）**：
   - 幂等方法（GET、PUT、DELETE、OPTIONS）多次调用不会产生副作用。
   - 非幂等方法（POST、PATCH）需谨慎处理重复请求。

2. **安全方法（Safe Methods）**：
   - GET 和 OPTIONS 是安全的（只读操作）。

3. **RESTful API 设计**：
   - 通常用 `POST` 创建资源，`GET` 读取，`PUT/PATCH` 更新，`DELETE` 删除。

4. **跨域请求（CORS）**：
   - 复杂请求（如带自定义头的 POST）会先触发 `OPTIONS` 预检请求。

---

### **总结**
理解 HTTP 请求方法是设计和使用 Web API 的基础。实际开发中需根据操作类型（创建、读取、更新、删除）和幂等性需求选择合适的方法，并遵循 RESTful 最佳实践。HTTPS 则确保这些操作在传输过程中的安全性。



------

# 第一章

## TCP/IP 协议族

+ 计算机与网络设备要相互通信，双方就必须基于相同的方法。比如， 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通 信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 **协议**（protocol）

+ TCP/IP 协议族按层次分别分 为以下 4 层：**应用层、传输层、网络层和数据链路层**
  + 应用层 
    + 应用层决定了向用户提供应用服务时通信的活动。
    + HTTP 协议也处于该层。
  + 传输层
    + 传输层对上层应用层，**提供处于网络连接中的两台计算机之间的数据传输**。
    + 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）
  + 网络层（又名网络互连层）
    + 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。
    + 该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。
    + 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是**在众多的选项内选择一条传输路线**。
  + 链路层（又名数据链路层，网络接口层）
    + 用来处理连接网络的硬件部分。
    + 包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。

+ 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通 信。**发送端从应用层往下走，接收端则往应用层往上走**。

  ![http1](D:\Zewang\Java_learning_java学习笔记\Notes\images\http1.png)

+ 以HTTP举例说明：
  + 首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。
  + 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。
  + 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。
  + 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。

+ 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。 
+ 这种把数据信息包装起来的做法称为封装（encapsulate）

![http2](D:\Zewang\Java_learning_java学习笔记\Notes\images\http2.png)

------



## 与 HTTP 关系密切的协议 : IP、TCP 和 DNS

### IP （Internet Protocol）

+ 负责传输
+ 位于**网络层**
+ 几乎 所有使用网络的系统都会用到 **IP 协议**
+ **IP 协议的作用是把各种数据包传送给对方**。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）
  + IP 地址指明了节点被分配到的地址
  + MAC 地址是指网卡所属的固定 地址
  + IP 地址可以和 MAC 地址进行配对
  + IP 地址可变换，但 MAC 地址基本上不会更改

+ 使用 **ARP 协议**凭借 **MAC 地址**进行**通信**

  **IP 间的通信依赖 MAC 地址**。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行**中转**时，会利用**下一站中转设备的 MAC 地址**来搜索**下一个中转目标**。这时，会采用 **ARP 协议**（Address Resolution Protocol）。**ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址**

+ 在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。这种机制称为**路由选择（routing）**

  > 有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中

![ARP.npg](D:\Zewang\Java_learning_java学习笔记\Notes\images\ARP.npg.png)

------



### TCP

+ 确保可靠性

+ 位于**传输层**，提供可靠的**字节流服务**

  + 字节流服务：为了方便传输，将大 块数据分割成以**报文段（segment）**为单位的**数据包**进行管理。而可 靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， **TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方**

+ **确保数据能够到达目标** *（重点）*

  + **三次握手**（three-way handshaking）

    用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。  握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。

    + **发送端首先发送一个带 SYN 标志的数据包给对方。**
    + **接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。**
    + **最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。**
    + 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。

------



### DNS

+ 提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务
+ 和 HTTP 协议一样位于应用层的 协议

> 用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表 示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅 长处理一长串数字。

![DNS](D:\Zewang\Java_learning_java学习笔记\Notes\images\DNS.png)

------



### 各种协议与HTTP协议的关系

![协议关系](D:\Zewang\Java_learning_java学习笔记\Notes\images\协议关系.png)

 

------



## URI和URL

### 统一资源标识符

+ URI 是 Uniform Resource Identifier 的缩写
  + Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文 环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易
  + Resource：资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例 如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另 外，资源不仅可以是单一的，也可以是多数的集合体
  + Identifier：表示可标识的对象。也称为标识符
+ 综上所述，URI 就是由**某个协议方案表示的资源的定位标识符**。协议 方案是指**访问资源所使用的协议类型名称**。
+ 采用 HTTP 协议时，协议方案就是 http。*除此之外，还有 ftp、 25 mailto、telnet、file 等*

+  URI 用字符串**标识**某一互联网资源，而 URL 表示资源的地点（互联 网上所处的位置）。
+ **可见 URL 是 URI 的子集。**

------

### URI格式

+ 表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以 及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL， 形如 /image/logo.gif。

+ 绝对URI：
  ![绝对URI](D:\Zewang\Java_learning_java学习笔记\Notes\images\绝对URI.png)

+ 使用`http: `或 `https:`  等协议方案名获取访问资源时要指定协议类型。不 区分字母大小写，最后附一个冒号（:）

+ 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名

+ 登录信息（认证）：

  + 指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份 认证）。

  + 此项是可选项。

+ 服务器地址：

  + 使用绝对 URI 必须指定待访问的服务器地址
  + 。地址可以是类似 `hackr.jp` 这种 DNS 可解析的名称，
  + 或是` 192.168.1.1` 这类 IPv4 地址 名，
  + 还可以是 `[0:0:0:0:0:0:0:1]` 这样用方括号括起来的 IPv6 地址名。

+ 服务器端口号：

  + 指定服务器连接的网络端口号。
  + 此项也是可选项，若用户省略则自动 使用默认端口号

+ 带层次的文件路径：
  指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件 目录结构相似。
+ 查询字符串：
  + 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参 数。
  + 此项可选。
+ 片段标识符：
  + 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个 位置）
  + 该项也为可选 项

------



# 第二章 简单的HTTP协议

> 主要针对HTTP/1.1

## HTTP协议用于

+ 用于**客户端和服务器**之间的通信
+ 请求**访问**文本或图像等资源的一端称为客户端，
+ 而提供资源**响应**的一端称为服务器端。

## 请求和响应

+ 通过请求和响应的交换达成通信
+ HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返 回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有 接收到请求之前不会发送响应。

### 请求

+ 例子：
  ![客户端](D:\Zewang\Java_learning_java学习笔记\Notes\images\客户端.png)

+ GET：请求类型，方法
+ `/index.htm` ： 请求访问的资源对象，请求URI
+ HTTP/1.1：HTTP的版本号
+ 意思：请求访问某台HTTP的/index.htm 页面资源
+ 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段 和内容实体构成的![请求报文](D:\Zewang\Java_learning_java学习笔记\Notes\images\请求报文.png)

### 响应

```http
HTTP/1.1 200 OK
 Date: Tue, 10 Jul 2012 06:50:15 GMT
 Content-Length: 362
 Content-Type: text/html
 <html>
 ……
```

+ 在起始行开头的 HTTP/1.1 表示服务器对应的 **HTTP 版本**。 
+ 紧挨着的 200 OK 表示请求的处理结果的状态码（status code）和**原因 短语**（reason-phrase）。
+ 下一行显示了创建响应的**日期时间**，是首部 字段（header field）内的一个属性。 
+ 接着以一空行分隔，之后的内容称为资源实体的**主体**（entity body）。
+ 响应报文基本上由**协议版本、状态码**（表示请求成功或失败的数字代 码）、**用以解释状态码的原因短语、可选的响应首部字段以及实体主 体**构成。

## HTTP是不保存状态的协议

+ 无状态
  自身不对请求和响应之间的通信状态进行保存
+ 每当有新的请求发送时，就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。
+ HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 **Cookie 技术**。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。

## 请求URI定位资源

+ HTTP 协议使用 URI **定位**互联网上的资源。正是因为 URI 的特定功 能，在互联网上任意位置的资源都能访问到。![URI定位资源](D:\Zewang\Java_learning_java学习笔记\Notes\images\URI定位资源.png)

+ 当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的 请求 URI 包含在内。
+ 指定请求 URI 的方式有很多
+ 除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 * 来代替请求 URI。

## 告知服务器意图的HTTP方法

+ GET：获取资源
  + 用来请求访问已被 URI 识别的资源
  + 指定的资源经服务器 端解析后返回响应内容
  + 如果请求的资源是文本，那就保 持原样返回；
  + 如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果
  + **访问资源**
  + 例子：
    ![GET例子](D:\Zewang\Java_learning_java学习笔记\Notes\images\GET例子.png)

+ POST：传输实体主体
  + 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。
  + 虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容
  + **把信息告诉服务器**

+ PUT：传输文件

  + 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法
  + 若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法
  + **把信息传给服务器**

+ HEAD：获得报文首部

  + HEAD 方法和 GET 方法一样，只是不返回报文主体部分。
  + 用于确认 URI 的有效性及资源更新的日期时间等。
  + **获得相关信息**

+ DELETE：删除文件

  + 与PUT相反的方法
  + HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的

+ OPTIONS：询问支持的方法

  + 客户端询问服务端支持哪些方法

+ TRACE：追踪路径

  + 让 Web 服务器端将之前的请求通信环回给客户端的方 法
  + 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 
  + 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。 
  + 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了

  ![TRACE](D:\Zewang\Java_learning_java学习笔记\Notes\images\TRACE.png)

+ CONNECT: 要求用隧道协议连接代理

  + CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。
  + 主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输

  ![CONNECT](D:\Zewang\Java_learning_java学习笔记\Notes\images\CONNECT.png)

## 持久连接节省通信量

+ HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。

![通信示意图1](D:\Zewang\Java_learning_java学习笔记\Notes\images\通信示意图1.png)

![通信示意图2](D:\Zewang\Java_learning_java学习笔记\Notes\images\通信示意图2.png)

### 持久连接

+ 持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态

![通信示意图3](D:\Zewang\Java_learning_java学习笔记\Notes\images\通信示意图3.png)

+ 好处：
  + 减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载
  + 减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了
+ 在 HTTP/1.1 中，所有的连接默认都是持久连接
+ 但在 HTTP/1.0 内并 未标准化

### 管线化

+ 持久连接使得多数请求以管线化（pipelining）方式发送成为可能
+ 从 前发送请求后需等待并收到响应，才能发送下一个请求
+ 管线化技术 出现后，不用等待响应亦可直接发送下一个请求
+ 这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待 响应了

![管线化](D:\Zewang\Java_learning_java学习笔记\Notes\images\管线化.png)

## 使用Cookie的状态管理

+ HTTP无状态，不对之前发生过的请求和响应的状态进行管 理（无法根据之前的状态进行本次的请求处理）
  优点：
  + 由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗
  + 正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里
  + 如果让服务器管理全部客户端状态则会成为负担
+ Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态
+ Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie
+ 当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去

![Cookie1](D:\Zewang\Java_learning_java学习笔记\Notes\images\Cookie1.png)

![Cookie2](D:\Zewang\Java_learning_java学习笔记\Notes\images\Cookie2.png)

+ 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息

+ 理解：档案
  每个人（客户端）有一个档案，当去到新的工作场所或学校（服务器）时，将档案（Cookie）给工作场所或学校（服务器），他们就能知道你是谁（客户端信息状态）

+ HTTP 请求报文和响应报文的内 容
  1.请求报文（没有 Cookie 信息的状态）

  ```http
  GET /reader/ HTTP/1.1
   Host: hackr.jp
   *首部字段内没有Cookie的相关信息
  ```

  2.响应报文（服务器端生成 Cookie 信息）

  ```http
  HTTP/1.1 200 OK
   Date: Thu, 12 Jul 2012 07:12:20 GMT
   Server: Apache
  ＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,
   10-Oct-12 07:12:20 GMT＞
  Content-Type: text/plain; charset=UTF-8
  ```

  3.请求报文（自动发送保存着的 Cookie 信息）

  ```http
  GET /image/ HTTP/1.1
   Host: hackr.jp
   Cookie: sid=1342077140226724
  ```

  